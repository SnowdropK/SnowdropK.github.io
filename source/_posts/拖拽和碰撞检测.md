---
title: 拖拽和碰撞检测
date: 2020-05-01 16:52:23
tags:
---

### 一、盒子拖拽

原生JS：拖拽目标元素到页面任意位置

<iframe height="265" style="width: 100%;" scrolling="no" title="YzzXEyK" src="https://codepen.io/OrangeSnow/embed/YzzXEyK?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/YzzXEyK'>YzzXEyK</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

<!-- more -->

#### 思路

1、onmousedown（鼠标按下事件） ：获取鼠标在盒子中的坐标，保证移动后鼠标在盒子的指定位置（x、y）
x = pagex - box.offsetLeft
y = pagey - box.offsetTop
2、onmousemove（鼠标移动事件） ：移动后鼠标的位置（x2,y2），减去鼠标在盒子中的坐标，就是盒子移动后的坐标
document.onmousemove
//给box赋值
box.style.left = (x2 – x) + "px"
box.style.top = (y2 - y) + "px"
3、onmouseup（鼠标抬起事件）：事件解绑
document.onmousemove = null

#### 注意点

1、变成绝对定位，脱离文档流才可以移动
2、鼠标移动事件绑定在document上，优化性能

### 二、碰撞检测：矩形—矩形

拖拽两个矩形div进行碰撞检测

<iframe height="265" style="width: 100%;" scrolling="no" title="ZEEGaOR" src="https://codepen.io/OrangeSnow/embed/ZEEGaOR?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/ZEEGaOR'>ZEEGaOR</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

#### 逻辑

外接图形判别法，判断任意两个矩形的任意一边是否无间距，从而判断是否碰撞。

#### 算法

```
rect1.x < rect2.x + rect2.width &&
rect1.x + rect1.width > rect2.x &&
rect1.y < rect2.y + rect2.height &&
rect1.height + rect1.y > rect2.y
```
以上逻辑封装成碰撞检测函数bump(box1,box2),进行复用

### 三、碰撞检测：圆形—圆形

拖拽两个圆形div进行碰撞检测

#### 逻辑

过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。

<iframe height="265" style="width: 100%;" scrolling="no" title="rNNVYWZ" src="https://codepen.io/OrangeSnow/embed/rNNVYWZ?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/rNNVYWZ'>rNNVYWZ</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

#### 公式

两点之间的距离公式，两个圆心之间的距离

#### 算法

```
Math.sqrt(Math.pow(circleA.x - circleB.x, 2) + Math.pow(circleA.y - circleB.y, 2)) 
< circleA.radius + circleB.radius
```

### 四、碰撞检测：圆形—矩形

拖拽圆形和矩形div进行碰撞检测

<iframe height="265" style="width: 100%;" scrolling="no" title="KKKpyWQ" src="https://codepen.io/OrangeSnow/embed/KKKpyWQ?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/KKKpyWQ'>KKKpyWQ</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

#### 逻辑

通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。

#### 判断条件

对于 x轴：
如果圆心在矩形的左侧（if(circle.x < rect.x)），那么 closestPoint.x = rect.x
如果圆心在矩形的右侧（else if(circle.x > rect.x + rect.w)），那么 closestPoint.x = rect.x + rect.w
如果圆心在矩形的正上下方（else），那么 closestPoint.x = circle.x
对于 y 轴：
如果圆心在矩形的上方（if(circle.y < rect.y)），那么 closestPoint.y = rect.y。
如果圆心在矩形的下方（else if(circle.y > rect.y + rect.h)），那么 closestPoint.y = rect.y + rect.h。
如果圆心在矩形的正左右两侧（else），那么 closestPoint.y = circle.y

#### 算法
```
var distance = Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))
if(distance < circle.r) return true // 发生碰撞
else return false // 未发生碰撞
```

### 五、碰撞检测：圆形—旋转矩形

拖拽圆形和旋转矩形div进行碰撞检测

<iframe height="265" style="width: 100%;" scrolling="no" title="dyyMJNb" src="https://codepen.io/OrangeSnow/embed/dyyMJNb?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/dyyMJNb'>dyyMJNb</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

#### 逻辑

1、一个物体相对于另一个物体的位置发生了变化，这个物体就在运动。
2、简化模型，变为普通的圆形与矩形碰撞检测

#### 计算过程

     目标值：C(c,d)的坐标，即相对旋转后的圆心坐标
1、已知条件：设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)
2、由于 |AB| 与 |CB| 相等（即长度），且
     已知条件： |AB| = y/sin(δ) = x / cos(δ)
     已知条件： |CB| = d/sin(δ + β) = c / cos(δ + β)
3、已知条件：半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)
4、由以下三角函数两角和差公式：
    sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)
    cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)
5、可得出旋转后的坐标：
    c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)
    d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)
6、实际坐标公式
    x’= cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerX
    y’= sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY

#### 算法
```
x’= Math.cos(radian) * (cx - centerX) - Math.sin(radian) * (cy - centerY) + centerX
y’= Math.sin(radian) * (cx - centerX) + Math.cos(radian) * (cy - centerY) + centerY
```


### 六、碰撞检测：像素-像素

拖拽不规则的图形，在像素级别进行碰撞检测

<iframe height="265" style="width: 100%;" scrolling="no" title="VwwLrzL" src="https://codepen.io/OrangeSnow/embed/VwwLrzL?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/VwwLrzL'>VwwLrzL</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

#### 逻辑

1、根据每一像素来判定是否碰撞，性能要求比较高。通常情况下，先对图像所在的矩形进行碰撞检测，当两个矩形碰撞时，再从像素级别进行判断
2、所在矩形发生碰撞后，再在像素级别进行比较，提高性能
3、获取两个精灵图像在相交矩形的像素数据，在相交矩形区域进行遍历判断，若两个图像在同一位置的值都不为0，则发生碰撞

2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测。因为这两种形状的碰撞检测速度是最快的。
其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。
AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。


#### 算法
```
var rect //相交矩形的数据对象，sx, sy, sw, sh
var kyuubiImg //图像1
var narutoImg //图像2
if(rect[0] >= rect[2] || rect[1] >= rect[3]) {//如果没有相交则退出 } else{
    //获取精灵在相交矩形像素数据
    kyuubiImg.data = backBuf.getImageData(rect[0],rect[1],rect[4],rect[5]).data;
    narutoImg.data = backBuf.getImageData(rect[0],rect[1],rect[4],rect[5]).data;
    for(var i=3;i<kyuubiImg.data.length;i+=4){
        if(kyuubiImg.data[i] > 0 && narutoImg.data[i] > 0){
                    //发生碰撞
        }
     }
}
```

#### 七、小Demo：颜色选择器

<iframe height="265" style="width: 100%;" scrolling="no" title="ExxjbvM" src="https://codepen.io/OrangeSnow/embed/ExxjbvM?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/OrangeSnow/pen/ExxjbvM'>ExxjbvM</a> by Sakura
  (<a href='https://codepen.io/OrangeSnow'>@OrangeSnow</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>

CanvasRenderingContext2D.getImageData() 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。
ctx.getImageData(sx, sy, sw, sh)
参数
sx：将要被提取的图像数据矩形区域的左上角 x 坐标。
sy：将要被提取的图像数据矩形区域的左上角 y 坐标。
sw：将要被提取的图像数据矩形区域的宽度。
sh：将要被提取的图像数据矩形区域的高度。
返回值
一个 ImageData 对象，包含 canvas 给定的矩形图像数据。
ImageData 对象会有三个属性，height、width 和 data。
ImageData.height
使用像素描述 ImageData 的实际高度，这个值其实等于 getImageData() 方法中的参数 sh
ImageData.width
使用像素描述 ImageData 的实际宽度。这个值其实等于 getImageData() 方法中的参数 sw
ImageData.data
一个一维数组，包含以 RGBA 顺序的数据，数据使用 0 至 255（包含）的整数表示


```
示例代码：
var ctx = canvas.getContext('2d');
// 获取鼠标坐标
var x = event.layerX
var y = event.layerY
// 获取图片像素信息
var pixel = ctx.getImageData(x, y, 1, 1)
var data = pixel.data
 // 获取rgba值
var rgba = 'rgba(' + data[0] + ',' + data[1] +',' + data[2] + ',' + (data[3] / 255) + ')';
// 设置小正方形的背景颜色
color.style.background =rgba;
```

引用：
1、[javascript动画系列第三篇——碰撞检测](https://www.cnblogs.com/xiaohuochai/p/5899228.html)
2、[用 canvas 的 getImageData 做点有趣的事](http://www.imooc.com/article/79972?block_id=tuijian_wz)
3、[“等一下，我碰！”——常见的2D碰撞检测](https://aotu.io/notes/2017/02/16/2d-collision-detection/index.html)
4、[使用html+javascript实现游戏常用算法演示](https://github.com/krapnikkk/JS-gameMathematics)
5、[工具网站：图片转换Base64](http://imgbase64.duoshitong.com/)
6、[GitHub搭建Hexo博客教程](https://cczeng.github.io/2017/05/03/git/%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8Github-Pages%E6%90%AD%E5%BB%BA%E8%B5%B7%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E2%80%94%E2%80%94%E7%BB%86%E6%95%B0%E4%B8%80%E8%B7%AF%E7%9A%84%E5%9D%91/)
7、[圆与旋转矩形的碰撞检测（下篇）](https://my.oschina.net/fgreshrht/blog/378961)
8、[碰撞检测的向量实现](https://flashgene.com/archives/66663.html)
9、[通过js获取元素css3的transform rotate旋转角度方法](https://www.cnblogs.com/qwguo/p/6678830.html)