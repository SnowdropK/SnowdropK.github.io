---
title: 算法二：搜索、排序
date: 2020-11-15 13:46:23
tags:
---
>排序：把某个乱序的数组变成升序或者降序的数组（JS:sort()）</br>
>搜索：找出数组中某个元素的下标（JS:indexOf()）
[排序算法演示网站](https://visualgo.net/zh/sorting)
<!-- more -->
## 排序算法
### 冒泡算法
时间复杂度：O（n2）
```
Array.prototype.bubbleSort() = function() {
    for(let i = 0; i < this.length - 1; i++) {
        for(let j = 0; j < this.length - 1 - i; j++) {
            if(this[j] > this[j + 1]) {
                const temp = this[j];
                this[j] = this[j + 1];
                this[j + 1] = temp;
            }
        }
    }
}

const arr = [2,4,7,9];
arr.bubbleSort();
```

### 选择排序
>找到数组中最小的值，选中它并将其放在第一位；</br>
>找到数组中第二小的值，选中它并将其放在第二位；</br>
>以此类推，执行n-1轮
时间复杂度：O（n2）
```
Array.prototype.selectionSort() = function() {
    for(let i = 0; i < this.length; i += 1) {
        let indexMin = i;
        for(let j = i; j < this.length; j += 1) {
            if(this[j] < this[indexMin]){
                indexMin = j;
            }
        }
        if(indexMin !== i) {
            const temp = this[i];
            this[i] = this[indexMin];
            this[indexMin] = temp;
        }
    }
}

const arr = [2,4,7,9];
arr.selectionSort();
```

### 插入排序
>从第二个数开始往前比；</br>
>比它大就往后排；</br>
>以此类推进行到最后一个数
时间复杂度：O（n2）
```
Array.prototype.insertionSort() = function() {
    for(let i = 0; i < this.length; i += 1) {
        const temp = this[i];
        let j = i;
        while(j > 0) {
            if(this[j - 1] > temp) {
                this[j] = this[j - 1];
            } else {
                break;
            }
            j -= 1
        }
        this[j] = temp
    }
}

const arr = [2,4,7,9];
arr.insertionSort();
```

### 归并排序
>分：把数组劈成两半，再递归地对子数组进行“分”操作，直到分成一个个单独的数。</br>
>合：把两个数合并成有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组。

时间复杂度：分（O(logN)），合（O(n)），分合（O(n * logN)）
```
Array.prototype.mergeSort() = function() {
    const rec = (arr) => {
        if(arr.length === 1) { return arr; };
        const mid = Math.floor(arr.length / 2);
        const left = arr.slice(0, mid);
        const right = arr.slice(mid, arr.length);
        const orderLeft = rec(left);
        const orderRight = rec(right);
        const res = [];
        while(orderLeft.length || orderRight.length) {
            if (orderLeft.length && orderRight.length) {
                res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift());
            } else if (orderLeft.length) {
                res.push(orderLeft.shift());
            } else if (orderRight.length) {
                res.push(orderRight.shift());
            }
        }
        return res;
    };
    const res = rec(this);
    res.forEach((n, i) => { this[i] = n; })
}

const arr = [5,4,3,2,1];
arr.mergeSort();
```
### 快速排序
>分区：从数组中任意选择一个基准，所有比基准小的元素放在基准前，所有比基准大的元素放在基准后面。</br>
>递归：递归地对基准前后的子数组进行分区。

时间复杂度：递归（O(logN)），分区（O(n)），分合（O(n * logN)）
```
Array.prototype.quickSort() = function() {
    const rec = (arr) => {
        if (arr.length === 1 ) { return arr; }
        const left = [];
        const right = [];
        const mid = arr[0];
        for (let i = 0; i < arr.length; i += 1) {
            if (arr[i] < mid) {
                left.push(arr[i]);
            } else {
                right.push(arr[i]);
            }
        }
        return [...left, mid, ...right];
    };
    const res = rec(this);
    res.forEach((n, i) => { this[i] = n; });
}

const arr = [5,4,3,2,1];
arr.quickSort();
```

## 搜索算法
### 顺序搜索
>1、遍历数组</br>
>2、找到跟目标值相等的元素，就返回它的下标</br>
>3、遍历结束后，如果没有搜索到目标值，就返回-1</br>

时间复杂度：O(n)
```
Array.prototype.sequentialSearch() = function(item) {
    for(let i = 0; i < this.length; i += 1) {
        if (this[i] === item) {
            return i;
        }
    }
    return -1;
}

const arr = [5,4,3,2,1];
const res = arr.sequentialSearch(3);
```

### 二分搜索
>前提：数组是有序的</br>
>从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束</br>
>如果目标值大于或小于中间元素，则在大于或小于中间元素的那一半数组中搜素</br>

时间复杂度：O(logN)
```
Array.prototype.binarySearch() = function(item) {
    let low = 0;
    let high = this.length - 1;
    while(low <= high) {
        const mid = Math.floor((low + high) / 2);
        const element = this[mid];
        if (element < item) {
            low = mid + 1;
        } else if (element > item) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    return -1;
}

const arr = [5,4,3,2,1];
const res = arr.binarySearch(3);
```
#### leetcode
21、374

chrome的排序方法Array.prototype.sort()内部实现原理